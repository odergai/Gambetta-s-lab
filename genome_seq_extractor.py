__author__ = 'odergai'
"""genome_extractor extracts genomic sequences according to coordinates provided in bed file.
    The ouptput is printed to STDOUT.
    The script take as input gzip file for genome and standard bed file for genomic intervals.
    IMPORTANT: make sure chromosome names in genome file and bed file match.
    fasta.gz files could be generated by make_bychrom_fasta.py
    
    Args:
        :param -g : path to genome, it could be either a single .gz file or a folder containing bunch of .gz files 
        for each chromosomes. 
        :param -b : path to bed file. bed file need to be in 6 column format (tab-delimited):
            Chr start end name score strand 
        :param -f : format, could be either interval, i or fasta, f.
            
            
    Prints:
        Chr start end strand sequence if -f is set to interval or i 
        standard fasta is printed if -f fasta of fa 
    """



import gzip
import numpy as np
import pandas as pd
import argparse
import operator
import os
import glob
from my_function1 import reverse_complement


try:
    parser = argparse.ArgumentParser(description = "genome_extractor.py extracts genomic sequences according to coordinates provided in bed file")
    parser.add_argument("-b","--bed", dest="path_to_bed", type=str, help="path to bed file in 6 column format\n\
                    field strand is required")
    parser.add_argument("-g", "--genome", dest = 'path_to_genome', type = str,
                        help='path_to_genome file')
    parser.add_argument('-f', "--format", dest ="format", type = str,
                    help = 'output format: intervals or fasta',
                    choices= ['interval','i','fasta','fa'])
    args = parser.parse_args()
except NameError:
    sys.stderr.write(
            "An exception occured with argument parsing. Check your provided options.")




def convert_int(v):
    try:
        return int(v)
    except ValueError:
        return v

def process_bed(filename = ''):
    """Open bed file and make pandas Data.frame and sort it"""
    bedfile = open(filename, "r")
    intervals = bedfile.readlines()
    intervals = [K.rstrip().split('\t') for K in intervals]
    labels = ['chr', 'start', 'end', 'name', 'score', 'strand']
    df = pd.DataFrame(intervals, columns= labels)
    df = pd.DataFrame(([convert_int(c) for c in l] for l in df.values), columns=labels)
    return df.sort_values(['chr', 'start'], ascending= [1,1])

bed = process_bed(filename=args.path_to_bed)


def open_genome_file(path_to_genome = args.path_to_genome):
    """open genome containing .gz file and returns dictionary {'chr': sequence} """
    genome_file = gzip.open(path_to_genome, "rt")
    genome1 = genome_file.read()
    genome = genome1.split('>')
    genome_file.close()
    genome_dict = {}
    for chr in genome:
        chunk = chr.split('\n')
        chr_name = chunk[0].split(' ')[0]
        genome_dict[chr_name] = ''.join(chunk[1:])
    return genome_dict


def output_from_file():
    """print to STDOUT sequences in fasta format"""
    genome_dict = open_genome_file()
    for index, row in bed.iterrows():
        subseq = genome_dict[str(bed['chr'][row.name])][row['start'] - 1: row['end']]
        if row['strand'] == '+':
            subseq = subseq
        elif row['strand'] == '-':
            subseq = reverse_complement(subseq)
        if args.format in ['interval', 'i']:
            print(row['chr'], row['start'], row['end'], row['strand'], subseq)
        elif args.format in ['fasta', 'f']:
            seq_name = '_'.join([str(k) for k in [row['chr'], str(row['start']), str(row['end']), row['strand']]])
            print('> {0}'.format(seq_name))
            print(subseq)


def alocate_chromosome(chr_name = 'chr1'):
    """open chromosome containing gz file, reads it and closes the source file"""
    bychrom_file = args.path_to_genome + '/' + chr_name + '.fasta.gz'
    print(bychrom_file)
    chr_file = gzip.open(bychrom_file, "rt")
    chr_seq = chr_file.read()
    chr_file.close()
    return chr_seq
#
#
#
def output_from_dir():
    """Iterates over multiple sequence-containing files and extracts genomic sequence"""
    chr_names = list(set(bed['chr']))
    for CHR in chr_names:
        chr_seq = alocate_chromosome(chr_name = CHR)
        for index, row in bed.iterrows():
            subseq = chr_seq[row['start'] - 1: row['end']]
            if row['strand'] == '+':
                subseq = subseq
            elif row['strand'] == '-':
                subseq = reverse_complement(subseq)
            if args.format in ['interval','i']:
                print(row['chr'], row['start'], row['end'], row['strand'], subseq)
            elif args.format in ['fasta','fa']:
                seq_name = '_'.join([str(k) for k in [row['chr'], str(row['start']), str(row['end']), row['strand']]])
                print('> {0}'.format(seq_name))
                print(subseq)

if __name__ == '__main__':
    if os.path.isfile(args.path_to_genome):
        output_from_file()
    if os.path.isdir(args.path_to_genome):
        output_from_dir()

